접근 권한 제어자
	다른 패키지 혹은 다른 클래스에서 해당 필드에 접근할 수 있는
	권한을 제어해주는, 설정해주는 키워드들

	(default)	: 다른 패키지에서 접근 불가
	public		: 모든 곳에서 접근 가능
	private		: 다른 클래스, 다른 패키지에서 접근 불가
	protected	: 다른 패키지에서 접근 불가 /
			단 자식은 자신의 필드처럼 접근 가능

	public - 모든곳에서 자유롭게 접근이 가능해야 하는 필드들
		(데이터를 처리하고 기능을 담당하는 메소드들)
	private - 데이터를 담는 변수들(게시글 제목, 회원 아이디, ...)
	protected - 상속이 목적(자식 클래스들이 오버라이딩 해서 써야하는 메소드)
	(default) - 확실하게 같은 패키지에서만 이용할 때, 귀찮을 때

	private 필드는 직접 접근할 방법이 하나도 없기 때문에 무조건
	public 메소드를 통해서 간접적으로 접근한다.
	(값을 사용하는 경우 : getter / 수정하는 경우 : setter)

추상 클래스(불완전한 클래스)
	추상적인 내용만 정의하고 있는 클래스로, 구체적인 내용은 존재하지 않는 클래스
	상속받은 하위 클래스에서 그 내용들을 구현하도록 설계된 클래스이다.
	추상 클래스(부모)는 클래스들(자식)의 공통 요소들을 추상적으로
	가상화 시켜놓기 때문에 객체화시 자식에서 재정의를 통한 구현을 하고
	그 자식타입으로 객체화를 진행해서 사용한다. 부모 추상 클래스의 역할은
	단지 자식 클래스를 만들 때 틀로 존재해서 도와주는 역할을 수행한다.
	그렇기 때문에 자식 클래스에서 재정의 해야되는 메소드의 이름과 형태만
	가지고 있다. 즉 메소드에 {}(바디)가 없다. 이러한 메소드를 추상 메소드
	라고 하며, abstract 라는 키워드가 리턴타입 앞에 붙는다. 추상 메소드가
	하나라도 포함되어 있다면 그 클래스는 추상 클래스로 만들어야 한다.

추상 클래스 선언
	abstract class 추상클래스명{
		abstract 리턴타입 추상메소드명();
	}
	추상 메소드는 자식 클래스에서 강제적으로 반드시 재정의 해야한다.
	일반 메소드도 추상 클래스 내부에 존재할 수 있다.

인터페이스
	추상 클래스를 고도화시킨 문법이며, 반드시 추상메소드와 상수만
	선언해야 한다. 다른 클래스에서 인터페이스를 지정받을 때에는
	implements 라는 키워드를 사용한다. 지정받은 클래스는
	인터페이스가 가지고 있는 추상 메소드를 반드시 재정의 해야한다.

	jdk 8버전 이후로부터는 인터페이스에 default 메소드를 선언할 수 있다.
	따라서 사실상의 다중상속을 지원하게 된다.
	인터페이스 끼리나 다른 클래스와의 메소드 모호성이 발생한다면
	(같은 이름의 메소드끼리 충돌이 발생한다면) 상속받은 클래스에서
	명시적으로 작성(오버라이딩)해 주어 모호성을 해결해 주어야 한다.
	내부에서는
		인터페이스명.super.메소드()
	로 지정받은 인터페이스에 있는 메소드를 호출할 수 있고 이는 다중상속을
	받을 수 있다는 것을 의미한다.

내부 클래스(inner class)
	클래스 내부에 클래스를 선언하며 외부 클래스의 필드에 용이하게 접근하기
	위해서 사용한다. 내부 클래스의 필드를 사용하기 위해서는 먼저 외부 클래스의
	객체를 만들고 그 객체를 통해 내부 클래스까지 접근해서 객체화를 해야한다.
	외부 클래스의 필드에서는 자신이랑 같이 올라와 있는 내부 클래스를 바로
	객체화 할 수 있다. 보통은 어떤 메소드의 호출 결과로 내부 객체를
	부여받아서 사용하는 방식으로 설계된다.
	
	외부클래스명 객체명 = new 외부클래스생성자();
	외부클래스명.내부클래스명 객체명 = 외부클래스객체.new 내부클래스생성자();

내부 클래스를 사용하는 이유
	1. 상속처럼 이용
		외부 클래스의 필드를 마치 내것처럼 접근하여 사용하기 위함

	2. 캡슐화
		외부 클래스의 객체가 없다면 내부 클래스도 존재할 수 없기 때문에
		다른 클래스에서 접근하지 못하도록 내부 클래스를 숨기기 위함

가정 : B클래스의 b() 메소드가 자주 쓰이고 이 작업은 A 클래스의 데이터가 필요하다.
만약 다른 곳에서는 b() 메소드가 전혀 안쓰이거나, B 클래스를 외부에 노출시키고 싶지
않거나, B 클래스의 객체가 있기 전에 필수적으로 A 클래스의 객체가 있어야 한다면
설계를 내부 클래스 형태로 만들어서 사용한다.























